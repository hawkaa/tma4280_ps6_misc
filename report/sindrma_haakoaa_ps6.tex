\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage[utf8]{inputenc}
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{color, xcolor}
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage[norsk]{babel}
\usepackage{amsmath}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}

\lhead{\exerciseGroup} % Top left header
\chead{\exerciseClass: \exerciseTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs


% Document data

\newcommand{\exerciseTitle}{Øving 6} % Assignment title
\newcommand{\exerciseClass}{TMA4280} % Course/class
\newcommand{\exerciseGroupMembers}{Sindre Magnussen og Håkon Åmdal}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\title{
\vspace*{\stretch{1}}
\noindent\HRule
\begin{center}
 \Huge
 \noindent	\exerciseClass \\
 \noindent \exerciseTitle \\ [4mm]
 \large
 \noindent\emph{\exerciseGroupMembers}
\noindent\HRule \newline
\end{center}
\vspace{0cm}
\begin{center}
	\includegraphics[width=10cm]{img/kongull.jpg}
\end{center}
\vspace*{\stretch{3}}
\begin{center}
\end{center}
}
% Insert date here if you want it to appear below your name

\newcommand{\ub}[1]{\underbar{$#1$}\,}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}
\lstset{escapechar=@,style=customc}


\begin{document}
\pagestyle{empty}
\maketitle

\thispagestyle{empty}

\newpage \tableofcontents


\newpage

\pagenumbering{arabic}

\section{Introduksjon - Poisson-problemet}
Poisson-ligningen er en av de mest kjente partielle diffensialligingene, og skrives på formen:
\begin{equation}
	-\nabla^2 u = f
\end{equation}
Her er $\nabla^2$ kjent som Laplace-operatoren.\\
\\
Liginingen brukes som en matematisk modell til å beskrive flere fysiske systemer, som oftest diffusjonsprosesser. Eksempler på typiske fysiske fenomener hvor poisson-ligningen kan brukes som modell er beregning av elektrisk felt, tilnærminger av strømninger i fluider og varmeoverføring uten varmetap. Poisson-ligingen dukker også opp når man skal regne ut egenverdier.\\
\\
Et poissonproblem er et problem der man skal finne en løsning til poisson-ligningen gitt en funksjon $f$ og et domene. Domenet har også grensebetingelser, slik at problemet har en unik løsning. Problemet vi skal løse i denne øvingen lyder som følgende:
% Dette er tatt direkte fra ps6.tex %
\begin{eqnarray}
	-\nabla^2 u & = & f \hspace{.5in} \textrm{in} \,\,\, \Omega = (0,1)\times (0,1) \\
	u & = & 0 \hspace{.5in} \textrm{on} \,\,\, \partial\Omega\, .
\end{eqnarray}
Her er $f$ en funksjon vi kjenner,  og $u$ er løsningen vi skal komme frem til. Vi har gitt at et enhetskvadrat  er vårt domenee, og at verdiene i kantene av dette kvadratet er $0$ (homogene Dirichlet grensebetingelser). En annen forutsetning er at $f$ må ligge i L2.\\
\\
Siden denne skal løses på en datamaskin, og en datamaskin har begrenset med ressurser (minne/regnekraft), må vi finne en tilnærming til løsningen $u$. Det finnes flere måter å diskretisere poisson-ligningen på, blant annet endelige differanser, endelige elementer og endelige volumer. Felles for disse er at alle ender opp med et sett med ligninger som kan skrives på formen:
\begin{equation}
	\label{eq:linear-system}
  \ub{A} \ub{u} = \ub{g}
\end{equation}

\begin{figure}[t]
	\label{fig:finite-difference}
	\centering
	\includegraphics[width=10cm]{img/finite-difference.png}	
	\caption{Oppretting av et ligningsystem ved hjelp av endelige differanser. Figur funnet i \cite{rdw}. }
	
\end{figure}

Siden \emph{TMA4280} underviser i endelige differanser, og dette er ofte beskrevet som den enkleste metoden, er dette også utgangspunktet for denne oppgaven. Oppgaven beskriver et todimensjonalt poissonproblem, og da fylles ligningssettet ut med en maske som vist i figur \ref{fig:finite-difference} (fempunktsformelen).

\section{Mulige løsningsstragegier}
Når vi har fått et ligningssystem på formen vist i ligning \ref{eq:linear-system}, gjenstår det å finne en metode å løse dette på. Det finnes mange metoder, og noen av metodene utnytter egenskaper ved ligningssystemene fra poissonproblemet for å effektivisere plassforbruk og kjøretid.
\subsection{Direkte metoder}
Dirkete metoder løser et system med ligninger i et endelig og forutsigbart antall steg, og er spesielt egnet når matrisene er symmetriske og positivt definitt (som ligningssettet produsert ved hjelp av endelige differanser). Eksempelet på den mest generiske direkte metoden er LU-faktorisering, med følgende asymptotiske egenskaper:
\begin{align*}
      \mathcal{N}_{op} &\sim \mathcal{O}(N^3), \\
      \mathcal{M} &\sim \mathcal{O}(N^2).
\end{align*}
Her er $N$ antall ukjente,  $\mathcal{N}_{op}$ antall FLOP og $\mathcal{M}$ minnebruk (i bytes). Flere optimaliseringer av LU-faktoriseringer finnes, det er særlig vanlig å utnytte at matrisen er glissen for å redusere minnebruk og antall flyttallsoperasjoner. \\
\\
Ved å utnytte ligningen som blir generert av fem-punktsformelen, kan vi diagonalisere ligningssystemet ved hjelp av egenvektorer og egenverdier, siden disse da er lette å regne ut. Grunnen til dette er at ligningssystemet vårt kan representeres ved et tensorprodukt.\\
\\
En av disse diagonaliseringsmetodene benytter seg av FFT (The Fast Fourier Transform), og har følgende asymptotiske egenskaper:
\begin{align*}
  \mathcal{N}_{op} &\sim \mathcal{O}(N \log N), \\
  \mathcal{M} &\sim \mathcal{O}(N).
\end{align*}
Denne tilnærmet optimale løsningen er strategien vi skal bruke for å løse poisson-problemet i denne øvingen. FFT har et konstant minnebruk og et arbeid på $\log N$ per frihetsgrad, hvilket er veldig bra.

\subsection{Iterative metoder}
I tillegg til direkte metoder, har vi også iterative metoder. En slik metode vil oppdatere løsningen i iterasjoner, og vil (forhåpentligvis) komme nærmere og nærmere for hver gang. Iterative metoder har som oftest et uforutsigbart antall iterasjoner, og vil vanligvis måtte bli stoppet av et kriterium gitt av brukeren. Jo strengere kriterium, jo flere iterasjoner. Antall iterasjoner vil også kunne variere fra problem til problem, selv om man benytter seg av samme algoritme.\\
\\
Generelt sett, drar iterative metoder fordel av at vi ikke lenger har noen krav om hvordan matrisen er lagret, og at minnebruk ofte er proposjonalt med antall ukjente. I tillegg, består metodene ofte av grunnleggende matrise-vektor-operasjoner, som ofte er optimalisert i soft- og hardware. Til slutt, er flere av disse metodene godt egnet for parallell prossesering. \\
\\
Eksempler på iterative metoder er \emph{Gauss-Jacobi}, \emph{Gauss-Seidel}, \emph{Generalized minimum residuial method} og \emph{Conjugate gradient method}. Brukt riktig, kan disse metodene være svært kraftige.

\section{Programkomponenter}
Rent overordnet har vi valgt å skrive nesten all kode i et felles bibliotek, og koblet på flere små programmer med ulike bruksområder. Det blir ingen nøye gjennomgang av koden i denne rapporten, da det befinner seg mange gode og beskrivende kommentarer der. Flere av funksjonene implementert regnes også som kjent av leseren av dette dokumentet, siden de er beskrevet i \cite{fast-poisson}. Det anbefales også å ta en titt på testene (beskrevet i seksjon \ref{subsection:unittest} og \ref{subsection:mpi_unittest}) for å få en dypere forståelse for input og forventet output.

\paragraph{Testing}
Vi bestemte oss tidlig for at det var langt viktigere med et program som gav riktig resultat enn et program som kjørte raskt. Vi har derfor hatt stor vekt på både enhets-testing og korrekthetstesting av løsning (konvergenstest) under utviklingen. Når programmet var ferdig, hadde vi derfor tilstrekkelig testdekning til å gjøre optimaliseringer. Bruk av tester har også forenklet kommunikasjonen mellom gruppens to medlemmer.

\paragraph{Tilstand}
Alle funksjoner i \emph{ps6\_common\_library} er bevisst programmert uten tilstand, og dette fører ofte til at parameterlistene er ganske lange. Dette er kun for å forenkle enhetstestene våre. Vi er ikke kjent med overhead knyttet til parameterpassing kontra globalt definerte variabler, men vi antar at det er neglisjerbart.

\subsection{ps\_6\_common\_library}
Denne programkomponenten inneholder mesteparten av koden for denne oppgaven. Den inneholder fire "inngangs"-funksjoner:
\begin{itemize}
	\item \emph{haha}
\end{itemize}

\subsection{possion}

\subsection{convergence}

\subsection{unittest}
\label{subsection:unittest}

\subsection{mpi\_unittest}
\label{subsection:mpi_unittest}
Dette programmet kjører enhetstester på funksjoner i \emph{ps\_6\_common\_library} som krever å bli kjørt i parallell med MPI. Den eneste funksjonen som testes i denne modulen, er \emph{transpose\_parallel}. Vi har valgt å ta ut testing av MPI-kode, siden vi ikke enkelt fikk \emph{Google Test} til å gi output på kun prosessor 0. Resultatet av denne testen er derfor rotete og vanskelig å lese. Testen kjøres med \emph{mpirun}, og 

\subsection{poisson\_orig}
Vi valgte å ta vare på det originale programmet vi fikk utlevert sammen med øvingen, slik at vi har et utgangpsunkt og mulighet til å sammenligne resultater.


\section{Poisson\_parallel()}

\section{Tester og resultater}
Med unntak av konvergenstestene, så ble testene gjennomført ved å kjøre programmet ti ganger. Den største og minste kjøretiden ble fjernet, og gjennomsnittet ble regnet ut. Koden for testene under ble kompilert med de samme instillingene, det vil si at både MPI og OpenMP var aktivert. 
Det vil si at vi kjørte programmene med \emph{mpirun} og heller varierte parameterene vi sendte med til kjøringen. Vi ville heller kjøre testene på en ekvivalent måte, enn å ha forsjellige måter å kjøre programmet på gitt forskjellige parametre. 

\subsection{Konvergens med ulik p}

\subsection{Kjøretid med forskellige p*t = 36}
Denne testen ble gjennomført for noen kombinasjoner som gir \emph{p} * \emph{t} = 36. Resultatet er vist i tabell \ref{p/t-table}.

\begin{table}
\begin{center}
	
	\begin{tabular}{c | c | c}
	\hline \hline 
	Antall prosesser      &    Antall tråder     &    Kjøretid (i sekunder) 	    \\ \hline	
	12		      &		1	     &	  32.690540       		    \\ \hline
	6		      &         2	     &    32.975599       		    \\ \hline
	4		      &         3	     &    33.223129	    		    \\ \hline
	3   		      &		2	     &    33.633001	    		    \\ \hline
	2		      &         6	     &    34.279941	    		    \\ \hline
	1		      &		12	     &    35.741616	    		    \\ \hline
	
	\end{tabular}
\end{center}
\caption{Kjøretider gitt forskjellige kompinasjoner av \emph{p} og \emph{t}.}
\label{p/t-table}
\end{table}

Som tabell \ref{p/t-table} viser, er det faktisk negativt å bruke en hybrid-løsning. Vi ser at kjøretiden blir litt større jo flere tråder vi bruker. Grunnen er at det koster å opprette og samle tråder. Så i dette tilfellet lønner det seg dermed å kjøre programmene med kun en tråd. 
Testene som følger denne vil dermed kun bruke en tråd og heller variere antall prosesser. 


\subsection{Speedup og effektivitet}


\section{Diskusjon og konklusjon}


\subsection{Å gå bort fra $f=1$}
\begin{figure}[h]
	\centering
	\lstinputlisting[frame=single, numbers=left]{code/local_f.c}
	\caption{Gå fra $f=1$ til en hvilken som helst funksjon $f(x, y)$.}
	\label{fig:local_f}
\end{figure}
For å håndtere en hvilken som helst todimensjonal funksjon $f(x, y)$, var det eneste som måtte gjøres å fylle ut $\ub{B}$ med verdier fra denne funksjonen. Her måtte vi bruke de lokale indeksene for å mappe $x$- og $y$-verdier og multiplisere funksjonsverdiene inn i matrisen. For å få dette til å kjøre i parallell måtte vi gjøre noen små justeringer når det gjaldt mapping fra lokale indekser til $x$- og $y$-verdier. Hver prossess lagrer kun sine egne rader, og en indeks til en rad i sin delvise (lokale) matrise vil mappe til en indeks i den fullstendige (globale) matrisen. Vi måtte derfor plusse på et offset på rad-indeksen når vi regnet ut verdien av $y$. Å gå fra $f=1$ til $f(x, y)$ fjerner med andre ord ikke noe parallelt potensiale, siden løkken som legger inn verdier i $\ub{B}$ ikke får noen avhengigheter som gjør at den ikke kan paralleliseres.

\subsection{Ikke-homogene Dirichlet grensebetingelser}
\begin{figure}[h]
	\centering
	\lstinputlisting[frame=single, numbers=left]{code/non_homogenous_dirichlet.c}
	\caption{Pseudokode for å addere grensebetingelsene inn i ligningssystemet.}
	\label{fig:non_homogenous_dirichlet}
\end{figure}
Dersom $u \neq 0$ i $\partial\Omega$, får vi ikke-homogene Dirichlet grensebetingelser. På generelt basis må man addere grensebetingelse inn i løsningsvektoren $\ub{b}$, eller i vårt tilfelle matrisen $\ub{B}$. Alle punkter i rutenettet som er nær en kant, må addere inn grensebetingelsene, det vil si verdiene til $u$ i $\partial\Omega$. En grov skisse av dette finner du i figur \ref{fig:non_homogenous_dirichlet}. \\
\\
Siden vi benytter oss av \emph{Fast Sine Transform} i denne oppgaven, må vi også være observante på hvordan grenseverdiene er definert. Dersom de er definert som Dirichlet grensebetingelser (vi kjenner verdien av $u(x, y)$ hvor $(x, y)\ \epsilon\ \partial\Omega$) vil sinustransformen fremdeles fungere.\\

\subsection{Piossonproblemet der $\Omega = (0, L_x) \times (0, L_y)$}
For å ta høyde for domener som ikke er definert som et enhetskvadrat, er det flere ting som må gjøres. For det første må vi gjøre om $h$ til $h_x = {L_x \over n}$ og $h_y = {L_y \over n}$. Mappingen på linjene 2 og 3 i figur \ref{fig:local_f} måtte da justeres til å ta høyde for disse ved å multiplisere hver indeks med korresponderende $h$-verdi i stedet for å dividere på $n$. I tillegg vil vi ikke lenger kunne multiplisere inn $h^2$ i steg 1, så steg 2 må modifiseres til å håndtere dette.\\
\\
Det er viktig å understreke at endring av $\Omega$ kun endrer på det fysiske domenet, ikke det logiske. Det er derfor ingen endringer som må gjøres i FST-algoritmen eller i utregning av diagonalen. Siden vi benytter oss av en direkte metode, vil vi ikke lide av ytelsestap, noe iterative metoder ofte gjør.
\subsection{Forslag til forbedringer}

\input{sections/bibliography.tex}
\end{document}
